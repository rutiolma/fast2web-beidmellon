<?php
/**
 * @file
 * Belgian National Number Field Module. Based on Password Field module.
 */

/**
 * Implements hook_field_info().
 */
function fedict_national_number_field_info() {
  return array(
    'fedict_national_number' => array(
      'label' => t('Belgian National Number'),
      'description' => t('A Belgian National Number (one-way encrypted)'),
      'default_widget' => 'fedict_national_number_widget',
      'default_formatter' => 'fedict_national_number_formatter',
    ),
  );
}

/**
 * Implements hook_field_formatter_info().
 */
function fedict_national_number_field_formatter_info() {
  return array(
    'fedict_national_number_formatter' => array(
      'label'       => t('Belgian National Number field formatter'),
      'field types' => array('fedict_national_number'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function fedict_national_number_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  switch ($display['type']) {
    case 'fedict_national_number_formatter':
      foreach ($items as $delta => $item) {
        if (!empty($item['fedict_national_number'])) {
          $natnum_out = '••••••••••••••••';
          $element[$delta]['#markup'] = '<span>' . $natnum_out . '</span>';
        }
      }
      break;
  }
  return $element;
}

/**
 * Implements hook_field_widget_form().
 */
function fedict_national_number_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $field_name = $field['field_name'];
  $field_type = $field['type'];

  $default_natnum = $instance['default_value'][0][$field_type][$field_type];


  if ($instance['widget']['type'] === 'fedict_national_number') {

    $dsc_key     = '#description';
    $default_dsc = t('Belgian National Number will remain unchanged if left blank.');
    $description = (empty($element[$dsc_key])) ? $default_dsc : $element[$dsc_key];
    $weight      = (isset($element['#weight'])) ? $element['#weight'] : 0;

    $natnumfield = field_get_items($element['#entity_type'], $element['#entity'], $element['#field_name']);
    if (isset($natnumfield[$delta]['fedict_national_number'])) {
      $title = filter_xss($element['#title']) . t(' (Already defined. Will remain unchanged if left blank.)');
    }
    else {
      $title = filter_xss($element['#title']);
    }

    $element['fedict_national_number'] = array(
      '#type'             => 'textfield',
      '#title'            => $title,
      '#description'      => filter_xss($description),
      // Number has 11 digits but we allow for 4 dashes/points.
      '#maxlength'        => 15,
      '#default_value'    => $default_natnum,
      '#required'         => $element['#required'],
      '#weight'           => $weight,
      '#delta'            => $delta,
      '#element_validate' => array('_fedict_national_number_validate'),
    );
  }
  return $element;
}

/**
 * Implements hook_field_widget_error().
 */
function fedict_national_number_widget_error($element, $error, $form, &$form_state) {
  switch ($error['error']) {
    case 'fedict_national_number_invalid':
      form_error($element, $error['message']);
      break;
  }
}

/**
 * Implements hook_field_is_empty().
 */
function fedict_national_number_field_is_empty($item, $field) {
  if (empty($item['fedict_national_number'])) {
    return TRUE;
  }
}

/**
 * Implements hook_field_widget_info().
 */
function fedict_national_number_field_widget_info() {
  return array(
    'fedict_national_number' => array(
      'label' => t('Belgian National Number'),
      'field types' => array('fedict_national_number'),
    ),
  );
}

/**
 * Gets field instance details.
 *
 * Given an element and form state, loads details of the field instance
 * and the entity type it is attached to.
 */
function _fedict_national_number_get_instance_details($element, $form_state) {

  // Parse the element name to determine field name, language, and delta.
  $pattern = '/^([^\[]+)\[([^\[]+)]\[([^\[]+)\]/';
  if (!preg_match($pattern, $element['#name'], $matches)) {
    return;
  }
  list($full_match, $field_name, $langcode, $delta) = $matches;

  // Get the entity type and the entity itself.
  $field_instance = $form_state['field'][$field_name][$langcode]['instance'];
  $entity_type    = $field_instance['entity_type'];

  return array(
    'field_name'  => $field_name,
    'langcode'    => $langcode,
    'delta'       => $delta,
    'entity_type' => $entity_type,
  );
}

/**
 * Loads field value.
 *
 * Given an element and form state, load the current value of the field
 * instance.
 */
function _fedict_national_number_load_current_value($element, $form_state) {
  // Get field details.
  $field_details = _fedict_national_number_get_instance_details($element, $form_state);
  $entity_type   = $field_details['entity_type'];

  // If there is no entity, then there can't be a value.
  if (empty($form_state[$entity_type])) {
    return;
  }

  $entity        = $form_state[$entity_type];
  $field_name    = $field_details['field_name'];
  $delta         = $field_details['delta'];

  // Load the field instance from DB and get the value.
  $natnumfield   = field_get_items($entity_type, $entity, $field_name);
  $natnumvalue   = (isset($natnumfield[$delta]['fedict_national_number']))
                     ? $natnumfield[$delta]['fedict_national_number'] : NULL;
  return $natnumvalue;
}

/**
 * Validation callback for National Number field.
 */
function _fedict_national_number_validate($element, &$form_state) {
  // If no value to encrypt, get out of here.
  if (!isset($element['#value'])) {
    return;
  }

  // If National Number value exists, but is empty, load old value and store that. This
  // means that if the field is left blank, then the value will be unchanged.
  if (empty($element['#value']) && !empty($form_state['field'])) {
    $natnumvalue = _fedict_national_number_load_current_value($element, $form_state);
    form_set_value($element, array('fedict_national_number' => $natnumvalue), $form_state);
    return;
  }

  try {
    $national_number = fedict_national_number_validate_and_sanitize($element['#value']);
    // If a new National Number value has been entered, hash it before saving.
    $value = _fedict_national_number_hash($national_number);
    form_set_value($element, array('fedict_national_number' => $value), $form_state);
  }
  catch (Exception $e) {
    form_error($element, t('Invalid National Number: ' . $e->getMessage()));
  }
}

/**
 * Hook to be called by other modules to match a user-inputted string against
 * a stored (hashed and salted) number.
 *
 * @param string $input
 *   Plain-text string to compare the hashed string against. Previous validation
 *   through fedict_national_number_validate_and_sanitize() is recommendend.
 *
 * @param string $stored_hash
 *   Hashed string to compare the plain-text string against
 *
 * @return bool
 *   TRUE if match, FALSE if no match.
 */
function fedict_national_number_match($national_number, $stored_hash) {
  require_once 'includes/password.inc';
  if (substr($stored_hash, 0, 3) != '$S$') {
    return FALSE;
  }
  $pepper = drupal_get_hash_salt();
  $peppered_national_number = hash_hmac('sha512', $national_number, $pepper);
  // See user_check_password().
  $hash = _password_crypt('sha512', $peppered_national_number, $stored_hash);
  return ($hash && $stored_hash == $hash);
}

/**
 * Hashes the National Number.
 *
 * Uses the same hashing algorithm as Drupal passwords, but uses the
 * $drupal_hash_salt global defined in settings.php in order to generate a peppered
 * version of the National Number.  This way, not only database access but also
 * PHP code access or settings.php access is needed for an attack.
 *
 * @param $national_number string
 *   National number in plain text.
 *
 * @return string
 *   The hashed, salted and peppered National Number.
 */
function _fedict_national_number_hash($national_number) {
  require_once 'includes/password.inc';
  // See http://security.stackexchange.com/questions/3272/password-hashing-add-salt-pepper-or-is-salt-enough
  $pepper = drupal_get_hash_salt();
  $peppered_national_number = hash_hmac('sha512', $national_number, $pepper);
  return user_hash_password($peppered_national_number);
}

/**
 * Checks whether National Number is valid and strips it from non-numeric
 * characters.
 *
 * Based on http://www.developed.be/2013/09/18/php-check-if-rijksregisternummer-is-valid/
 *
 * @param string $national_number
 *   The National Number
 *
 * @return string
 *   The sanitized/numeric National Number.
 *
 * @throws Exception
 *   if invalid National Number.
 */
function fedict_national_number_validate_and_sanitize($national_number) {
  $allowed_characters_pattern = "/^[0-9\ \-\.]+$/";
  $non_numeric_pattern = "/\D/";

  if (preg_match($allowed_characters_pattern, $national_number) != 1) {
    throw new Exception(t("Non allowed character in National Number."));
  }
  else {
    // Strip the number from all non numeric characters.
    $national_number = preg_replace($non_numeric_pattern, "", $national_number);

    // Length must be 11 digits.
    if (strlen($national_number) != 11) {
      throw new Exception(t("Length of the National Number is not 11 digits."));
    }
    else {
      $birth_date_ok = FALSE;
      $counter_ok = FALSE;
      $gender_ok = FALSE;
      $control_ok = FALSE;
      $born_2k_or_later = FALSE;

      // First 6 digits are birth date in format YYMMDD.
      $birth_date_part = substr($national_number, 0, 6);
      // Next 3 are counter.
      $counter_part = substr($national_number, 6, 3);
      // Last 2 are control number.
      $control_part = substr($national_number, 9, 2);

      /* 1. CONTROL NUMBER CHECKING */
      /******************************/
      // Calculate control number (= mod 97 of first 9 digits)
      $calculated_control = 97 - (($birth_date_part . $counter_part) % 97);

      if ($calculated_control != $control_part) {
        // If the calculated control part is different than the one in the
        // input sting, add a "2" in front of the birth date part and
        // recalculate. This was introduced to allow birthdates of year 2000
        // and later.

        $calculated_control = 97 - (("2" . $birth_date_part . $counter_part) % 97);

        if ($calculated_control != $control_part) {
          // The calculation still doesn't match the control number, so this
          // isn't a valid registry number.
          $control_ok = FALSE;
        }
        else {
          $born_2k_or_later = TRUE;
          $control_ok = TRUE;
        }
      }
      else {
        $control_ok = TRUE;
      }

      /* 2. BIRTHDATE CHECKING */
      /*************************/
      $birth_date = $birth_date_part;
      // Build the birth date to check.
      if ($born_2k_or_later == TRUE) {
        $birth_date = "20" . $birth_date_part;
      }
      else {
        $birth_date = "19" . $birth_date_part;
      }
      // End build.

      $birth_date_ok = checkdate(substr($birth_date, 4, 2), substr($birth_date, 6, 2), substr($birth_date, 0, 4));

      /* 3. COUNTER CHECKING */
      /***********************/
      // Counterpart must be between 001 and 997
      if ($counter_part >= 1 || $counter_part <= 997) {
        $counter_ok = TRUE;
      }

      /* 4. RETURN IF NO ERRORS */
      /*******************************/
      $messages = array();
      if (!$birth_date_ok) {
        $messages[] = t("invalid birth date (first 6 digits)");
      }
      if (!$counter_ok) {
        $messages[] = t("invalid counter (7th until 9th digit)");
      }
      if (!$control_ok) {
        $messages[] = t("invalid control number (last 2 digits)");
      }

      if (!empty($messages)) {
        throw new Exception(implode(', ', $messages) . '.');
      }
      else {
        return $national_number;
      }
    }
  }
}
